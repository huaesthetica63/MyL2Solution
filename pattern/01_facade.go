package pattern

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы,а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern
*/

/*
паттерн "фасад" предназначен для создания унифицированного интерфейса, который должен упростить использование системы,
состоящей из нескольких интерфейсов. Если для выполнения какого-либо действия необходимо осуществить множество разных операций,
можно ввести "фасадный" интерфейс, который предоставил бы нам один единственный метод, который упростит задачу,
осуществив все эти операции вместо нас. Например, если при запуске нашего приложения необходимо провести его инициализацию:
подключиться к базе данных, подключиться к удаленному серверу, вывести на экран начальную форму GUI,
загрузить переменные окружения и т.д. мы можем вызвать последовательно методы loadDB, loadServer, loadGui, loadEnv,
что сделает наш код громоздким и малопонятным, паттерн "фасад" позволит исправить это путем создания "оболочки" -
одного единственного метода initApplication , который и будет вызывать все эти методы вместо нас, и вместо нескольких строчек кода
нам останется написать только одну - с вызовом initApplication, это полезно и для уменьшения объема кода,
и для упрощения использования системы - другим разработчикам уже не надо вдаваться в детали инициализации приложения

в L0 можно было бы так же создать "фасадный" интерфейс, который объединил процессы подключения к бд, nats-серверу и тд
в один единственный метод init()

плюсы фасада: упрощает использование сложной системы, предоставляя пользователю "черный ящик с парой кнопок",
в подробности принципа работы которого можно не вдаваться, если это неинтересно, упрощает сам код, делая его лаконичнее -
если у нас есть часто повторяющаяся последовательность одних и тех же действий, чтобы не прописывать их всех каждый раз,
мы можем использовать объединяющий фасадный интерфейс

минусы фасада проявляются в том, что пользоваться системой так гибко уже не получится, если нам будет
предоставлен один большой готовый метод, делающий всю работу за нас. На том же примере с инициализацией приложения:
если мы захотим изменить способ подключения к бд или добавить/отбросить какой-либо метод - например, вместо загрузки GUI
в виде оконных форм захотим сделать веб-интерфейс (опять же, как это сделано в l0), то initApplication с готовой последовательностью
действий уже будет неактуальным для наших задач. Скрыта детальная реализация процессов, что отягощает понимание сути

Более жизненный пример: если представить акпп в машине как фасадный интерфейс механической трансмиссии, то
в большинстве случаев удобнее пользоваться им, не повторяя вручную каждый раз процесс переключения передач, выжима сцепления и тд,
но в случае поломки разбираться в причинах будет сложнее (реализация скрыта в большей степени), а также у нас
меньше контроля над поведением автомобиля (повлиять на расход или динамику уже нельзя, "алгоритм" акпп решил все за нас)
*/
import "fmt"

//реализуем с помощью фасада подготовку автомобиля к началу движения и остановку
type Engine struct {
	rpm int //число оборотов в минуту на данный момент
}

func (self *Engine) StartEngine() { //вставляем ключ и заводим двигатель
	self.rpm = 750 //количество оборотов сменилось с 0 до 750 - двигатель работает
	fmt.Println("Двигатель заведен!")
}
func (self *Engine) StopEngine() { //глушим двигатель
	self.rpm = 0 // обороты упали до нуля - все ок
	fmt.Println("Двигатель заглушен!")
}

type Transmission struct { //коробка передач
	gear int //текущая передача (0-нейтраль, 1-5 и -1- задняя)
}

func (self *Transmission) SetGear(i int) { //меняем передачу на заданную
	self.gear = i //когда начинаем движение, нужно перевестись на 1 передачу
	fmt.Printf("Передача переключена на %d!\n", self.gear)
}

type Handbrake struct { //ручной тормоз
	isActive bool //поднят ли ручной тормоз? (1/0 - да/нет)
}

func (self *Handbrake) SetHandbrake(act bool) { //меняем положение ручника
	self.isActive = act
	if act {
		fmt.Println("Ручник поднят!")
	} else {
		fmt.Println("Ручник опущен!")
	}
}

type Car struct { //структура, объединяющая все эти компоненты
	eng     Engine
	gearbox Transmission
	handbr  Handbrake
}
type CarFacade struct { //фасад
	car *Car
}

func (cf *CarFacade) startCar() { //начинаем движение
	cf.car.gearbox.SetGear(0)         //ставим нейтраль
	cf.car.eng.StartEngine()          //запускаем двигатель
	cf.car.handbr.SetHandbrake(false) //снимаем ручник
	cf.car.gearbox.SetGear(1)         //переключаем на первую
	fmt.Println("Бип-бип")            //ура!!!
} //фасад позволит спрятать очень много вызовов разных методов в одном лаконичном startCar
func (cf *CarFacade) stopCar() { //пора закругляться
	cf.car.gearbox.SetGear(0)        //ставим нейтраль
	cf.car.handbr.SetHandbrake(true) //ставим ручник
	cf.car.eng.StopEngine()          //глушим двигатель
	fmt.Println("Всё!")
} //фасад позволит спрятать очень много вызовов разных методов в одном лаконичном stopCar

func main() {
	var car Car
	var cf CarFacade
	cf.car = &car
	cf.startCar()
	cf.stopCar()
}
