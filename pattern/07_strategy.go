package pattern

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

/*
Паттерн "стратегия" предназначен для определения семейства алгоритмов,
сокрытия их реализации (принцип инкапсуляция), обеспечения взаимозаменяемости -
можно выбирать нужный алгоритм в зависимости от потребности

Паттерн применяется в тех случаях, когда системе нужно использовать
разные вариации какого-то алгоритма в своей работе, когда есть
множество схожих объектов, которые отличаются деталями в поведении

Пример использования: у нас есть система, где есть разные типы пользователей с
разными правами доступа (потребители, сотрудники, администратор),
нам необходимо реализовать функцию просмотра ассортимента товаров:
тогда для потребителей должна выводится информация, интересующая именно их,
сотрудникам выводится техническая информация о товаре (артикул, наличие на складе, дата завоза),
администраторам сервиса другая техническая информация: uid товара, какие-то иные идентификаторы
(как это было примерно в l0). Тогда алгоритм просмотра перечня товаров будет
реализован в нескольких вариациях, и тут мы можем воспользоваться паттерном "стратегия"

Плюсы: можно динамически определять, какой алгоритм будет запущен,
соблюдается инкапсуляция - код алгоритмов отделен и скрыт от остального кода,
алгоритмы вызываются единообразно: без if-ов и других подобных конструкций

Минусы: приходится создавать дополнительные структуры, что немного нагромождает код,
при проектировании системы нужно четко понимать, какие алгоритмы и когда применять,
в чем их отличия, чтобы не допустить логических ошибок
*/

import "fmt"

//приведем пример решения разного типа уравнений , метод SolveEquation ведет себя по-разному
//в зависимости от ситуации (уравнения, которое мы подадим на вход)
type Strategy interface {
	SolveEquation() //по сути мы сделаем интерактивный справочник, который в зависимости
	//от типа уравнения опишет алгоритм его решения
}
type Linear struct{} //линейное уравнение
func (l Linear) SolveEquation() {
	fmt.Printf("Линейное уравнение: ax+b=0\nx=-b/a\n")
}

type Quadratic struct{} //квадратное уравнение
func (q Quadratic) SolveEquation() {
	fmt.Printf("Квадартное уравнение: ax^2+bx+c=0\nD=b^2-4*a*c\nD<0-решений нет\nИначе: x1,2=(-b±√D)/(2a)\n")
}

type PowEquation struct{} //показательное уравнение
func (p PowEquation) SolveEquation() {
	fmt.Printf("Показательное уравнение: a^x=b\nx=loga(b)\n")
}
func main() {
	var info []Strategy //"справочник" с разными видами уравнений
	info = append(info, Linear{})
	info = append(info, Quadratic{})
	info = append(info, PowEquation{})
	for _, x := range info {
		x.SolveEquation()
	}
}
