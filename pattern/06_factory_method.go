package pattern

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
Фабричный метод - инструмент для делегирования создания разных объектов, тип которых определяют сами пользователи
паттерна. Данный паттерн применим в ситуациях, когда нам нужно сделать объекты разных типов, но заранее нельзя
предугадать, сколько и каких конкретно, когда нужно отделить код, связанный с созданием и использованием.
Жизненным примером, который раскрыл бы суть паттерна, можно назвать фабрику по производству соков,
фабричный метод позволяет создать интерфейс с методом "создать сок", а "подразделения" сами решат, какой сок именно:
яблочный, мультифрукт, томатный и т.д. и реализуют метод "создать сок" под конкретный тип. В фабрику могут
поступать разные заказы, по типу таких: выпустить N пачек апельсинового, M пачек яблочного и X пачек вишневого сока,
чтобы справиться с поставленной задачей, мы можем воспользоваться этим паттерном, тем самым сократив объем кода:
мы просто обратимся к отделам по производству каждого из видов сока, и они уже выполнят метод "создать сок" каждый
по-своему.

Реальные примеры использования: допустим, у нас есть структуры, предназначенные для работы с кэшем, базой данных,
удаленным сервером, файловой системой и тд - их основное предназначение: получать определенные данные (например, структуру
с информацией о заказе или клиенте), а затем куда-то ее записывать (структуры как раз отличаются тем, куда они пишут данные),
фабричный метод дает системе интерфейс с методом "записать", каждый из этих объектов реализует метод по-своему,
когда "записать" вызывается объектом для работы с бд - инфо записывается в бд, когда объектом для работы с кешем - в кеш,
и так далее. Когда мы захотим масштабировать систему и добавить запись еще в один источник, достаточно использовать
этот паттерн

Плюсы: разделяет код на часть с созданием объектов и на часть с их эксплуатацией, тем самым, уменьшая
зависимость структур друг от друга, делает систему более динамичной - мы можем не беспокоиться о том,
какой конкретно тип объектов создавать, систему легко масштабировать, добавляя новые структуры, использующие
тот же интерфейс фабричного метода

Минусы: в некоторых ситуациях использовать фабричный метод неудобно, потому что для каждого
типа объекта нужно создавать конкретную "фабрику" - объект, который будет порождающим, таким образом,
мы можем получить очень много структур, что может "засорить" код
*/

import "fmt"

//объясню паттерн на том же примере с соками
type Juice interface { //чтобы все разнотиповые соки реализовывали один и тот же общий интерфейс
	PrintJuice()
}
type AppleJuice struct { //яблочный сок

}

func (a AppleJuice) PrintJuice() { //реализовываем интерфейс
	fmt.Println("Это яблочный сок!")
}

type OrangeJuice struct { //апельсиновый сок

}

func (a OrangeJuice) PrintJuice() { //реализовываем интерфейс
	fmt.Println("Это апельсиновый сок!")
}

type TomatoJuice struct { //помидорный

}

func (a TomatoJuice) PrintJuice() { //реализовываем интерфейс
	fmt.Println("Это томатный сок!")
}

//на этом хватит
//теперь создаем фабричный метод, на вход подается тип сока, на выход - сок конкретного типа
func MakeJuice(juicetype string) Juice {
	if juicetype == "orange" {
		return OrangeJuice{}
	}
	if juicetype == "apple" {
		return AppleJuice{}
	}
	if juicetype == "tomato" {
		return TomatoJuice{}
	}
	return nil
}

func main() {
	var JuiceBox []Juice //большая коробка пачек сока
	JuiceBox = append(JuiceBox, MakeJuice("apple"))
	JuiceBox = append(JuiceBox, MakeJuice("apple"))
	JuiceBox = append(JuiceBox, MakeJuice("orange"))
	JuiceBox = append(JuiceBox, MakeJuice("apple"))
	JuiceBox = append(JuiceBox, MakeJuice("tomato"))
	for _, x := range JuiceBox { //выводим теперь информацию про каждый из них
		x.PrintJuice()
	}
}
