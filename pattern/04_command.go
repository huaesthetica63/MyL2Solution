package pattern

/*
	Реализовать паттерн «комманда».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern
*/

/*
Паттерн "команда" позволяет инкапсулировать запрос к системе в виде самостоятельного объекта. Применяется,
когда возникает необходимость передавать запросы как аргументы в методах, обрабатывать запросы как объекты
(создавать логи, очереди из запросов и т.д)

Паттерн уместен в случаях, когда у нашего приложения есть операции с возможностью undo/redo, как в
текстовых или графических редакторах, например. Также "команду" можно часто встретить в микросервисах,
которые используют сложные запросы, которые удобно представлять в виде объектов

Плюсы: паттерн позволяет сделать независимыми друг от друга объекты, которые вызывают и выполняют операции,
код, как и во всех случаях, когда используются уместные паттерны, становится понятнее в использовании
и чтении - мы можем создавать сложные команды, состоящие из нескольких простых команд (создать некую модульность),
код реализации команд отделен от других объектов - принцип инкапсуляции, предоставляется гибкость в обработке команд -
можно распределять их выполнение по потокам, ставить в очереди, отменять или повторять и тд

Минусы: зачастую код становится несколько сложнее в написании, потому что надо прописать много новых структур, интерфейс,
это не всегда оправдано в ситуациях, когда система компактная и не содержит большого обилия команд
*/

import "fmt"

//в качестве примера я приведу ситуацию с игровой консолью, где действия представлены с помощью данного паттерна
type Command interface {
	Execute() // интерфейс, который будут реализовывать все конкретные команды
}
type Device interface { //интерфейс, реализующий некоторый класс бытовой техники(его может также реализовать dvd-плеер)
	OnDevice()      //включить
	OffDevice()     //выключить
	OpenCloseTray() //изменить положение дисковода (представим, что это выполняет одна и та же кнопка)
}
type Console struct { //сама консоль
	isOn        bool //влкючена ли приставка?
	isConnected bool //подключена ли к тв/монитору?
	isOpenTray  bool // открыт ли дисковод
}

//начинаем реализовывать интерфейс девайса
func (cons *Console) OnDevice() {
	cons.isOn = true
	fmt.Println("Консоль включена!")
}
func (cons *Console) OffDevice() {
	cons.isOn = false
	fmt.Println("Консоль выключена!")
}
func (cons *Console) OpenCloseTray() {
	if cons.isOpenTray {
		cons.isOpenTray = false
		fmt.Println("Дисковод консоли закрыт!")
	} else {
		cons.isOpenTray = true
		fmt.Println("Дисковод консоли открыт!")
	}
}

//теперь создаем команды как отдельные структуры
type OnCommand struct {
	device Device
}

func (on *OnCommand) Execute() {
	on.device.OnDevice()
}

type OffCommand struct {
	device Device
}

func (off *OffCommand) Execute() {
	off.device.OffDevice()
}

type TrayCommand struct {
	device Device
}

func (tray *TrayCommand) Execute() {
	tray.device.OpenCloseTray()
}
func main() {
	var cons Console
	onComm := &OnCommand{
		device: &cons,
	}
	onComm.Execute()
	trayComm := &TrayCommand{
		device: &cons,
	}
	trayComm.Execute()
	trayComm.Execute()
	ofComm := &OffCommand{
		device: &cons,
	}
	ofComm.Execute()
}
